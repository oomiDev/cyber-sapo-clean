/**
 * üóÑÔ∏è CONFIGURACI√ìN DE BASE DE DATOS - CYBER SAPO
 * 
 * Este archivo es como el "CONECTOR" que permite que nuestro servidor
 * se comunique con la base de datos SQLite.
 * 
 * Piensa en esto como un "traductor" entre JavaScript y la base de datos:
 * - JavaScript habla en objetos y funciones
 * - La base de datos habla en SQL (lenguaje de consultas)
 * - Este archivo traduce entre ambos idiomas
 */

const sqlite3 = require('sqlite3').verbose();
const path = require('path');

/**
 * üèóÔ∏è CLASE PARA MANEJAR LA BASE DE DATOS
 * 
 * Esta clase es como un "ADMINISTRADOR DE BASE DE DATOS" que:
 * 1. Abre la conexi√≥n con la base de datos
 * 2. Crea las tablas si no existen
 * 3. Proporciona m√©todos para hacer consultas
 * 4. Cierra la conexi√≥n cuando terminamos
 */
class DatabaseManager {
    constructor() {
        // üìç RUTA donde est√° guardada nuestra base de datos
        // Es como la "direcci√≥n" del archivo donde guardamos toda la informaci√≥n
        this.dbPath = path.join(__dirname, '../../cyber_sapo_simple.db');
        
        // üîó CONEXI√ìN a la base de datos (inicialmente null)
        // Es como tener un "tel√©fono" para hablar con la base de datos
        this.db = null;
        
        console.log('üîß DatabaseManager creado - Ruta:', this.dbPath);
    }

    /**
     * üöÄ CONECTAR CON LA BASE DE DATOS
     * 
     * Es como "marcar el n√∫mero de tel√©fono" para establecer comunicaci√≥n
     * con la base de datos. Una vez conectados, podemos enviar y recibir informaci√≥n.
     */
    connect() {
        return new Promise((resolve, reject) => {
            console.log('üîå Conectando con la base de datos...');
            
            // Crear la conexi√≥n usando SQLite3
            this.db = new sqlite3.Database(this.dbPath, (err) => {
                if (err) {
                    console.error('‚ùå Error conectando con la base de datos:', err.message);
                    reject(err);
                } else {
                    console.log('‚úÖ Conectado exitosamente a la base de datos SQLite');
                    resolve();
                }
            });
        });
    }

    /**
     * üèóÔ∏è CREAR TODAS LAS TABLAS DE LA BASE DE DATOS
     * 
     * Las tablas son como "archivadores" donde organizamos la informaci√≥n:
     * - business_types: Tipos de negocios (bar, casino, etc.)
     * - locations: Ubicaciones donde est√°n las m√°quinas
     * - machines: Las m√°quinas de juego CYBER SAPO
     * - games: Registro de todas las partidas jugadas
     * - daily_machine_stats: Estad√≠sticas diarias por m√°quina
     * - hourly_machine_stats: Estad√≠sticas por hora
     */
    async createTables() {
        console.log('üèóÔ∏è Creando tablas de la base de datos...');
        
        return new Promise((resolve, reject) => {
            // db.serialize() hace que todas las operaciones se ejecuten en orden
            // Es como decir "haz esto paso a paso, no todo al mismo tiempo"
            this.db.serialize(() => {
                
                // üìã TABLA: business_types (Tipos de Negocio)
                // Guarda los diferentes tipos de lugares donde pueden estar las m√°quinas
                this.db.run(`CREATE TABLE IF NOT EXISTS business_types (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- N√∫mero √∫nico para cada tipo
                    name TEXT UNIQUE NOT NULL,              -- Nombre del tipo (ej: "bar", "casino")
                    icon TEXT DEFAULT 'üè¢',                -- Emoji que representa el tipo
                    description TEXT,                       -- Descripci√≥n del tipo de negocio
                    active INTEGER DEFAULT 1,              -- Si est√° activo (1) o no (0)
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP  -- Cu√°ndo se cre√≥
                )`, (err) => {
                    if (err) console.error('‚ùå Error creando tabla business_types:', err);
                    else console.log('‚úÖ Tabla business_types creada');
                });

                // üè¢ TABLA: locations (Ubicaciones)
                // Guarda informaci√≥n de cada lugar donde hay m√°quinas CYBER SAPO
                this.db.run(`CREATE TABLE IF NOT EXISTS locations (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- N√∫mero √∫nico para cada ubicaci√≥n
                    name TEXT NOT NULL,                     -- Nombre del lugar (ej: "Bar El Sapo Dorado")
                    country TEXT NOT NULL,                  -- Pa√≠s donde est√°
                    city TEXT NOT NULL,                     -- Ciudad donde est√°
                    address TEXT,                           -- Direcci√≥n completa
                    phone TEXT,                             -- Tel√©fono de contacto
                    email TEXT,                             -- Email de contacto
                    business_type TEXT DEFAULT 'other',     -- Tipo de negocio (conecta con business_types)
                    description TEXT,                       -- Descripci√≥n del lugar
                    latitude REAL,                          -- Coordenada GPS (latitud)
                    longitude REAL,                         -- Coordenada GPS (longitud)
                    active INTEGER DEFAULT 1,              -- Si est√° activo (1) o no (0)
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- Cu√°ndo se cre√≥
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP   -- Cu√°ndo se actualiz√≥ por √∫ltima vez
                )`, (err) => {
                    if (err) console.error('‚ùå Error creando tabla locations:', err);
                    else console.log('‚úÖ Tabla locations creada');
                });

                // üé∞ TABLA: machines (M√°quinas)
                // Guarda informaci√≥n de cada m√°quina CYBER SAPO
                this.db.run(`CREATE TABLE IF NOT EXISTS machines (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- N√∫mero √∫nico para cada m√°quina
                    name TEXT NOT NULL,                     -- Nombre de la m√°quina (ej: "CYBER-001")
                    location_id INTEGER NOT NULL,          -- En qu√© ubicaci√≥n est√° (conecta con locations)
                    status TEXT DEFAULT 'available',       -- Estado: 'available', 'occupied', 'offline'
                    total_games INTEGER DEFAULT 0,         -- Total de partidas jugadas en esta m√°quina
                    total_revenue REAL DEFAULT 0.0,        -- Total de dinero ganado por esta m√°quina
                    total_playtime INTEGER DEFAULT 0,      -- Total de tiempo jugado (en segundos)
                    last_game_at DATETIME,                  -- Cu√°ndo se jug√≥ la √∫ltima partida
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- Cu√°ndo se instal√≥ la m√°quina
                    FOREIGN KEY (location_id) REFERENCES locations (id)  -- Conecta con la tabla locations
                )`, (err) => {
                    if (err) console.error('‚ùå Error creando tabla machines:', err);
                    else console.log('‚úÖ Tabla machines creada');
                });

                // üéÆ TABLA: games (Partidas)
                // Guarda el registro de CADA partida que se juega
                this.db.run(`CREATE TABLE IF NOT EXISTS games (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- N√∫mero √∫nico para cada partida
                    machine_id INTEGER NOT NULL,           -- En qu√© m√°quina se jug√≥
                    location_id INTEGER NOT NULL,          -- En qu√© ubicaci√≥n se jug√≥
                    players_count INTEGER NOT NULL,        -- Cu√°ntos jugadores participaron
                    game_type TEXT DEFAULT 'individual',   -- Tipo: 'individual', 'parejas', 'equipos'
                    duration_seconds INTEGER NOT NULL,     -- Cu√°nto dur√≥ la partida (en segundos)
                    revenue REAL NOT NULL,                 -- Cu√°nto dinero gener√≥ esta partida
                    credits_used INTEGER DEFAULT 1,       -- Cu√°ntos cr√©ditos se usaron
                    winner_score INTEGER,                  -- Puntuaci√≥n del ganador
                    total_score INTEGER,                   -- Puntuaci√≥n total de todos los jugadores
                    started_at DATETIME NOT NULL,          -- Cu√°ndo empez√≥ la partida
                    ended_at DATETIME NOT NULL,            -- Cu√°ndo termin√≥ la partida
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- Cu√°ndo se registr√≥ en la base de datos
                    FOREIGN KEY (machine_id) REFERENCES machines (id),      -- Conecta con machines
                    FOREIGN KEY (location_id) REFERENCES locations (id)     -- Conecta con locations
                )`, (err) => {
                    if (err) console.error('‚ùå Error creando tabla games:', err);
                    else console.log('‚úÖ Tabla games creada');
                });

                // üìä TABLA: daily_machine_stats (Estad√≠sticas Diarias por M√°quina)
                // Guarda un resumen de cada d√≠a para cada m√°quina
                this.db.run(`CREATE TABLE IF NOT EXISTS daily_machine_stats (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- N√∫mero √∫nico para cada registro diario
                    machine_id INTEGER NOT NULL,           -- De qu√© m√°quina son las estad√≠sticas
                    location_id INTEGER NOT NULL,          -- En qu√© ubicaci√≥n est√° esa m√°quina
                    date DATE NOT NULL,                    -- Qu√© d√≠a (formato: 2024-01-15)
                    games_count INTEGER DEFAULT 0,         -- Cu√°ntas partidas se jugaron ese d√≠a
                    total_revenue REAL DEFAULT 0.0,        -- Cu√°nto dinero se gan√≥ ese d√≠a
                    total_playtime INTEGER DEFAULT 0,      -- Cu√°nto tiempo se jug√≥ ese d√≠a (segundos)
                    avg_players REAL DEFAULT 0.0,          -- Promedio de jugadores por partida
                    avg_duration REAL DEFAULT 0.0,         -- Duraci√≥n promedio de las partidas
                    peak_hour INTEGER,                     -- A qu√© hora hubo m√°s actividad
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- Cu√°ndo se calcul√≥ esta estad√≠stica
                    UNIQUE(machine_id, date),              -- No puede haber dos registros del mismo d√≠a para la misma m√°quina
                    FOREIGN KEY (machine_id) REFERENCES machines (id),      -- Conecta con machines
                    FOREIGN KEY (location_id) REFERENCES locations (id)     -- Conecta con locations
                )`, (err) => {
                    if (err) console.error('‚ùå Error creando tabla daily_machine_stats:', err);
                    else console.log('‚úÖ Tabla daily_machine_stats creada');
                });

                // ‚è∞ TABLA: hourly_machine_stats (Estad√≠sticas por Hora)
                // Guarda estad√≠sticas de cada hora del d√≠a para cada m√°quina
                this.db.run(`CREATE TABLE IF NOT EXISTS hourly_machine_stats (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- N√∫mero √∫nico para cada registro horario
                    machine_id INTEGER NOT NULL,           -- De qu√© m√°quina son las estad√≠sticas
                    location_id INTEGER NOT NULL,          -- En qu√© ubicaci√≥n est√° esa m√°quina
                    date DATE NOT NULL,                    -- Qu√© d√≠a
                    hour INTEGER NOT NULL,                 -- Qu√© hora (0-23)
                    games_count INTEGER DEFAULT 0,         -- Cu√°ntas partidas en esa hora
                    revenue REAL DEFAULT 0.0,             -- Cu√°nto dinero en esa hora
                    playtime INTEGER DEFAULT 0,           -- Cu√°nto tiempo de juego en esa hora
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- Cu√°ndo se calcul√≥
                    UNIQUE(machine_id, date, hour),        -- No puede haber duplicados
                    FOREIGN KEY (machine_id) REFERENCES machines (id),      -- Conecta con machines
                    FOREIGN KEY (location_id) REFERENCES locations (id)     -- Conecta con locations
                )`, (err) => {
                    if (err) console.error('‚ùå Error creando tabla hourly_machine_stats:', err);
                    else console.log('‚úÖ Tabla hourly_machine_stats creada');
                    
                    // Cuando terminemos de crear todas las tablas, resolvemos la promesa
                    resolve();
                });
            });
        });
    }

    /**
     * üå± INSERTAR DATOS INICIALES
     * 
     * Esto es como "llenar los archivadores" con informaci√≥n b√°sica
     * para que el sistema pueda funcionar desde el primer d√≠a.
     */
    async insertInitialData() {
        console.log('üå± Insertando datos iniciales...');
        
        // Primero insertamos los tipos de negocio
        const businessTypes = [
            { name: 'bar', icon: 'üç∫', description: 'Bar' },
            { name: 'pub', icon: 'üçª', description: 'Pub' },
            { name: 'restaurant', icon: 'üçΩÔ∏è', description: 'Restaurante' },
            { name: 'disco', icon: 'üï∫', description: 'Discoteca' },
            { name: 'cafe', icon: '‚òï', description: 'Caf√©' },
            { name: 'hotel', icon: 'üè®', description: 'Hotel' },
            { name: 'casino', icon: 'üé∞', description: 'Casino' },
            { name: 'mall', icon: 'üè¨', description: 'Centro Comercial' },
            { name: 'other', icon: 'üè¢', description: 'Otro' }
        ];

        // Preparar la consulta para insertar tipos de negocio
        // "INSERT OR IGNORE" significa "inserta solo si no existe ya"
        const stmt = this.db.prepare(`INSERT OR IGNORE INTO business_types (name, icon, description) VALUES (?, ?, ?)`);
        
        businessTypes.forEach(type => {
            stmt.run(type.name, type.icon, type.description);
        });
        
        stmt.finalize();
        console.log('‚úÖ Tipos de negocio insertados');
    }

    /**
     * üîç EJECUTAR UNA CONSULTA QUE DEVUELVE M√öLTIPLES RESULTADOS
     * 
     * Es como "hacer una pregunta" a la base de datos y recibir una lista de respuestas.
     * Por ejemplo: "¬øCu√°les son todas las m√°quinas disponibles?"
     */
    query(sql, params = []) {
        return new Promise((resolve, reject) => {
            this.db.all(sql, params, (err, rows) => {
                if (err) {
                    console.error('‚ùå Error en consulta:', err.message);
                    reject(err);
                } else {
                    resolve(rows);
                }
            });
        });
    }

    /**
     * üîç EJECUTAR UNA CONSULTA QUE DEVUELVE UN SOLO RESULTADO
     * 
     * Es como hacer una pregunta espec√≠fica que tiene una sola respuesta.
     * Por ejemplo: "¬øCu√°ntas partidas se jugaron hoy?"
     */
    get(sql, params = []) {
        return new Promise((resolve, reject) => {
            this.db.get(sql, params, (err, row) => {
                if (err) {
                    console.error('‚ùå Error en consulta get:', err.message);
                    reject(err);
                } else {
                    resolve(row);
                }
            });
        });
    }

    /**
     * ‚úèÔ∏è EJECUTAR UNA CONSULTA QUE MODIFICA DATOS
     * 
     * Es como "dar una orden" a la base de datos para cambiar algo.
     * Por ejemplo: "Inserta una nueva partida" o "Actualiza el estado de una m√°quina"
     */
    run(sql, params = []) {
        return new Promise((resolve, reject) => {
            this.db.run(sql, params, function(err) {
                if (err) {
                    console.error('‚ùå Error en consulta run:', err.message);
                    reject(err);
                } else {
                    // 'this' aqu√≠ se refiere al resultado de la operaci√≥n
                    // lastID = el ID del √∫ltimo registro insertado
                    // changes = cu√°ntos registros se modificaron
                    resolve({ lastID: this.lastID, changes: this.changes });
                }
            });
        });
    }

    /**
     * üö™ CERRAR LA CONEXI√ìN CON LA BASE DE DATOS
     * 
     * Es como "colgar el tel√©fono" cuando terminamos de hablar.
     * Importante hacerlo para liberar recursos del sistema.
     */
    close() {
        return new Promise((resolve, reject) => {
            if (this.db) {
                this.db.close((err) => {
                    if (err) {
                        console.error('‚ùå Error cerrando base de datos:', err.message);
                        reject(err);
                    } else {
                        console.log('‚úÖ Conexi√≥n con base de datos cerrada correctamente');
                        resolve();
                    }
                });
            } else {
                resolve();
            }
        });
    }
}

// üè≠ CREAR UNA INSTANCIA √öNICA DEL ADMINISTRADOR DE BASE DE DATOS
// Esto es un "patr√≥n singleton" - solo hay una conexi√≥n para toda la aplicaci√≥n
const databaseManager = new DatabaseManager();

// üì§ EXPORTAR para que otros archivos puedan usar la base de datos
module.exports = databaseManager;
